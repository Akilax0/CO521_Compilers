README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [cool root]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [cool root]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [cool root]/src/PA3/dumptype.cc
 handle_flags.c           -> [cool root]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [cool root]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [cool root]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [cool root]/src/PA3/tokens-lex.cc
 tree.cc		  -> [cool root]/src/PA3/tree.cc
 utilities.cc		  -> [cool root]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[cool root]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% make parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

by 

E/17/072 Dinuransika
E/17/154 Akilax0


Non-terminals
--------------


Types for the grammar's non-terminals are declared.

Already declared

%type<program> program
%type<classes> class_list
%type<class_> class


Declared by us

%type<features> feature_list
%type<feature> feature
%type<formals> formal_list
%type<formal> formal
%type<expressions> exp_let
%type<expressions> expr_param
%type<expressions> exp_block
%type<expression> expr
%type<cases> case_branches
%type<case> case_branch

Precedence Decalarations
-------------------------

Precedence of binary and unary operations are declared here.
Precedence for COOL is given in cool-manual.pdf(section 11.1) where the order 
from highest to lowest given as,

       .
       @
       ~
       isvoid
       * /
       + -
       <= < = 
       not
       <-

It is also given that all binary operations are left associative except
assignment which is right assiciative. And the three comparisons are not
associative.

Referring the BISON manual (section 5.3),
	  The precedence statements should be prefixed with %left %right
	  %nonassoc


	  The statement are declared in order of lowest to highest gor BISON
(5.3.2)


Grammar
--------

Grammar starts with a definition of program as a class_list. 

class_list ->
	if class take as single class

	if class_list class pass to append_Classes()

class -> 
	- CLASS TYPEID '{' '}' ';'
		pass to class_ when 
	- CLASS TYPEID '{' feature_list '}' ';'

	- CLASS TYPEID INHERITS TYPEID '{' '}' ';'

	- CLASS TYPEID INHERITS TYPEID '{' feature_list '}' ';'


feature_list
	Feature list can be empty itself but cannot have empty features.

feature
	Methods and attribute in class. Can have a variety of ways to define
	them,

	The attributes can have an initailization value or just the definition.

	OBJECTID ':' TYPEID ';'
		calls attr() without the initailization expression/value.

	OBJECTID ':' TYPEID ASSIGN expr ';'
		calls attr() with the initailization expression/value.

	The methods can be defined with or without formal lists. However empty 
	formals are taken care of when calling for them hence can use 
		
	OBJECTID '(' formal_list ')' ':' TYPEID '{' expr '}' ';'
		and callin method()

formals
	Parameters for methods
	Usual way of defining is 
		OBJECTID ':' TYPEID 
	can pass this by calling formal()

expr 
	Expressions that contain in the body of the program by referring 
	cool-manual.

	- OBJECTID 
		returns the a call to object() to return it as it is
	
	- OBJECTID ASSIGN expr
		returns a call to assign() with Symbol and expr parameters

	- BOOL_CONST
		handles boolean consts in expression with bool_const() call
	
	- INT_CONST
		handles int consts in expression with int_const() call

	- STR_CONST 
		handles string const in expression with string_const() call

	- Dispath or method calls are of three variants
		1) expr '.' TYPEID '(' expr_param ')' 
			here we call the dispatch() method. Most commonly used 
		method call. The evaluation happens by considering the 
		expressions in the expr_param left to right then the expr found
		outside  along with the function call.

		2) OBJECTID '(' expr_param ')' 
			calls the dispatch() method but reffering to the self 
		object. Also can be considered as a shorthand for 
			self.<id>(expr,expr..)

		3) expr '@' TYPEID '.' OBJECTID '(' expr_param ')'
			calls the static_dispatch() method. A way to access 
		methods from the parent classes. Here the method is called upon
		the expr on the right side of '@' by giving the class name
		(TYPEID) followed by a '.' and the method name(OBJECTID)
	
	- Conditionals 
		1) IF expr THEN expr FI
			calls the cond() method but without an expression for 
		the else case

		2) IF expr THEN expr ELSE expr FI
			call the cond() method with the expression for the else
		case. (A complete if else block)

	- Loops 
		1) WHILE expr LOOP expr POOL
			All while the first expression is true execute the 
		second expression. Calls the loop() method.

	- expression block

		Expression blocks are list of expressions sepereated by ';' 
		and put inside '{' '}' when using in COOL language.

	- case expressions
		Used to have handle different options according to a given 
		expression. typecase() method is called passing in the 
		selection expression and the case_branches which are defined as

		OBJECTID ':' TYPEID DARROW expr ';'
			and calls method branch().

	- New
		Defining a new class object is handled here by calling new_()
		and passing in the TYPEID. The expression takes the form of,
			NEW TYPEID


	- Isvoid
		Evaluates an expression to return a boolean. Handled by calling
		the isvoid() method on an expression as,
			ISVOID expr

	- Operators
		THe usual operators are encountered in the COOL language as 
			expr <op> expr

		for each operator relavant method is called.
		The operators handled here are,

		+ - / * < LE = ~ 

	- NOT 
		the NOT expr is handled by calling the comp() method.
		Basically looks for when expression is not occuring

	- paranthesis
		Expressions inside paranthesis are handled by extracting and
		returning the middle expression.

	-LET
		LET OBJECTID : TYPEID, OBJECTID : TYPEID, ... IN expr
		LET OBJECTID : TYPEID ASSIGN expr, OBJECTID : TYPEID ASSIGN expr, ... IN expr
			is handled by calling the let() method.
			And the expression can have above two mentioned forms.


Testing 
----------

First tests were done using the given good.cl and bad.cl just by running 
" make dotest " . Here we encountered issues of various expression definitions.
-> ASSIGN , dispatch.

The ASSIGN was not parsed in the first run through of the code as was fixed.
The dispatch issue however occured while trying to call methods of inherited classes. Soon we came to the concolusions of,

	1) multiple files are not meant to be parsed in the assignment
	2) The parser cannot handle classes defined in the file as there is no type checking implemented yet. This will be enabled after the implementation of semantic analyzer.

After the initial realizations we continued to test through individual implementations of rules. Mostly manually editing the good.cl file and also using already impelented classes , methods, assignments, operations available in the example files. The checks were done by looking at the parser outputs and going through the recognized parser 


Another issue we encountered was having shift reduce conflicts in the LET statements with the defined operators (expr <operator> expr).

However this was solved by assigning a higher priority to the LET statement there by reolving the issue.




