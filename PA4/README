README file for Programming Assignment 4 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 ast-lex.cc		-> [cool root]/src/PA4/ast-lex.cc
 ast-parse.cc		-> [cool root]/src/PA4/ast-parse.cc
 bad.cl
 cgen			-> [cool root]/etc/../lib/.i
 cool-tree.cc		-> [cool root]/src/PA4/cool-tree.cc
 cool-tree.h
 cool-tree.handcode.h
 dumptype.cc		-> [cool root]/src/PA4/dumptype.cc
 good.cl
 handle_flags.cc	-> [cool root]/src/PA4/handle_flags.cc
 mycoolc		-> [cool root]/src/PA4/mycoolc
 mysemant		-> [cool root]/src/PA4/mysemant
 semant-phase.cc	-> [cool root]/src/PA4/semant-phase.cc
 semant.cc
 semant.h
 stringtab.cc		-> [cool root]/src/PA4/stringtab.cc
 symtab_example.cc	-> [cool root]/src/PA4/symtab_example.cc
 tree.cc		-> [cool root]/src/PA4/tree.cc
 utilities.cc		-> [cool root]/src/PA4/utilities.cc
 *.d			  dependency files

The include (.h) files for this assignment can be found in 
[cool root]/include/PA4

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code.  Just edit this file.

	good.cl and bad.cl test a few features of the semantic checker.
	You should add tests to ensure that good.cl exercises as many
	legal semantic combinations as possible and that bad.cl
	exercises as many kinds of semantic errors as possible.

	semant.h contains declarations and definitions for the semantic
	analyzer.  Place class definitions for the structures you will
	use here.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.  DO
        NOT MODIFY.

        cool-tree.h, and cool-tree.handcode.h specify and give an
        implementation of Cool ASTs (see the README for PA3 and the
        "Cool Tour").  In this assignment, you will need to add
        functions to the AST classes to store, fetch, and compute
        information about the AST.  Note that cool-tree.handcode.h
        differs slightly from the file supplied for PA3.

   	You should NOT remove any definitions that are already present
	in cool-tree.h and cool-tree.handcode.h.  These functions and
	data members are required for the system to function properly.

        You should add any fields and methods to the classes you need to 
	perform semantic analysis.  You	will need to add, for example, 
	methods which traverse the expressions of the tree and implement 
	the type-checking rules.

	cool-tree.cc contains definitions of the provided methods,
	and instantiations of the template for the list handling functions.
	You should not modify this file, but place definitions of all
	methods you add to cool-tree.h or cool-tree.handcode.h in semant.cc.
	DO NOT MODIFY cool-tree.cc

	semant.cc is the file in which you should write your semantic
	analyzer.  The main() procedure calls the method `semant'
	on `ast_root', the root of the abstract syntax tree generated by
	the parser.  There are methods supplied that you should use to report 
	errors. You are relatively free in how you decide to structure the 
	semantic checker, but don't modify the error printing routines.

	ast-lex.cc and ast-parse.cc implement a lexer and a parser for
	reading text representation of ASTs from console in the format
	produced by the parser phase. DO NOT MODIFY.

	semant-phase.cc contains a test driver for semantic analysis.
	The main program reads an AST in text form from standard input,
	parses it, and then produces a type-annotated AST on standard
	output.  The script mycoolc can pass any of the standard flags
	to the semantic analyzer as well; for this assignment, -s
	(semantic analysis debug) may be useful as it sets a global
	variable semant_debug to true (1).  If you want your semantic
	checker to print debug information when the option is set, write
	your debug code in the following format:

	      if (semant_debug)
	      {
		...
	      }

	semant_debug is provided as a convenience. You don't need to use
	the debugging flags if you don't want to. DON'T MODIFY
	semant-phase.cc

	symtab.h contains a symbol table implementation. Read the
	comments in the file, the "Cool Tour", and look at the example
	in symtab_example.cc.  You are not required to use this code,
	but you may find it useful. DO NOT MODIFY.

Instructions
------------

	To compile the example use of the symbol table, type

	% make symtab_example
        % ./symtab_example

	To compile your semantic analyzer program type:

	% make semant

	To test your semantic checker, type:

        % ./mysemant good.cl

	mysemant is a version of mycoolc that omits code generation.
	mysemant parses all the cool files given on the command line and
	builds a single abstract syntax tree containing all class
	definitions appearing in the input files. Your semantic checker
	is then called on this abstract syntax tree.  If there are no
	errors, the program produces a type-annotated abstract syntax
	tree as output.

	To run your checker on the files good.cl and bad.cl type:

	% make dotest

	If you think your semantic checker is correct and behaves like
	the one we wrote, you can try to run mycoolc using your checker,
	your parser and also your lexical analyzer if you choose (see
	below for instructions).  Remember if your lexer, parser or
	checker behaves in an unexpected manner, you may get errors
	anywhere.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA4
----------------

E/17/072 Dissanayake D.M.D.R.
E/17/154 Karunanayake A.I.


The semantic analyzer works mainly in two parts
	1) Identifying/ checking inheritance for the defined classes
	2) Check the graph is well-formed
	3) For each identified class 
		a) Traverse the AST while gathering visible declarations in a
		symbol table.
		b) Check each expression for type correctness
		c) Annotate the AST with types.

	

Edited files
	semant.cc
	
	ClassTable::ClassTable
		Constructor method for class table. Responsible for class type
		checking and inheritance. The method begins by getting a 
		classes list and installing them. (Adding classes to the 
		classes table)
		At this stage error checks are done for 
			1. type == SELF_TYPE
				Omitted as redundant of classes tree.
			2. repeated classes
				classes table contains unique entries for each 
				class

		Once the installing process is done we have a list of classes 
		(classes_table) created for the program. Next checks for correct
		inheritance is done.
			flag valid_inheritance is used to keep track of the
		correct inheritance.
		
		Iterates through the class list while recording parent classes
		and children.
		Here checks are done to see if
			1. parent class is valid
			2. check if current class is inherited form anything 
			other than object and IO classes.
			3. cyclic inhreitance
				iterate through the recorded parents if the
				class has been encountered. If so inheritance
				cycle making the inheritance check invalid.
		At the end of the method if inheritance is valid three methods
		are called.
			1. traverse AST and adding declarations  ->
				decl_class(root_class)
			2. Do type checking on the AST ->
				type_check_class(root_class)
			3. Check for main class / main method 
				


	
	ClassTable::decl_class
		Method to declare classes found on the AST. Initially we get a
		list of features for the class considered, then iterates through
		each and declare methods and attributes. At the end,  for all
		children classes of the current class call decl_class to keep
		moving through the AST.

	ClassTable::type_check_class 
		The method reads class name / Symbol and checks if it belongs to
		one of the base classes.
			Obect, Int, Str, Bool , IO

		if the class type check passes iterate through the list of
		features of the class and call ype checking on the attributes
		and methods using, 
			type_check_attr()
			type_check_method()

		At the the end check for type of child classes calling the
		method,
			type_check_class()

	ClassTable::decl_attr
		Method called to declare an attribute of a given class.Checks
		done, 
			1. If attribute type is defined or if SELF_TYPE it is
			allowed.
			2. self as  a attribute name is not allowed.
			3. Check for predefined attributes and methods. If so
			error.

		If the checks are satisfied adds the attribute to the symbol
		table. 

	ClassTable::decl_method
		Method called to declare a method of a given class. Iterates
		through the formals of the method while keeping track of the
		argument symbols. For each formal,
			1. self is not allowed (cannot bind self as a parameter)
			2. Check among other arguments to see if repeated. Not
			allowed to have arguments with same name.
	 	if the checks are satisfied add the names to the argument list.

	Note: Method declarations


	ClassTable::type_check_attr 
		Checks the attribute type when an attribute and its class is paassed to
		the methhod. Get the exression of the attribute and the symbol(type). If
		the expression type is not NULL call type_check_expression. 

	ClassTable::type_check_method 
		Iterates through the list of formals for the passed method and adds them
		to the symbol table. Calls type check expression for the method
		expression.	

	ClassTable::type_check_expression
		Most of the above methods use this function as expressions are the base
		of formals, methods, and attributes. According to the type of the
		expression passed to the function the final type is assigned by looking
		at the correct type usages. Implentation is of the form of a switch case
		statement.

		The first set of expressions calls methods defined for the relevent
		expressions. 
			assign,static_dispatch, cond, typecase, block, loop, new_, object,
			let

		Next are the arithmetic checks,
			eq, lt, leq

		??
			neg, comp, isvoid
		
		Checking for the same type (arithmetic)
			plus,sub, mul, divide
	
		Constants with direct final type declarations
			string_const--> Str
			bool_const --> Bool
			int_const --> Int
			no_expr --> No_type

		For the inalid expressions an Obyect is declared as final with error
		message. All the other (default) would get an "unhandled expression "
		message.

		If final type is not No_type and returns false on is_descendant which
		checks if final type is a descende of the expected type error message is
		given for the type conversion. 

	ClassTable::invalid_comparison
		When two symbols are passed checks if both are not equal types and does
		not belong to any basic types.

	From here on out the methods for type checking for different scenarios are
	documented.


	ClassTable::type_check_eq
		Gets the types defined by type_check_expression for the two 

	ClassTable::type_check_assign 
		Checks if the name is self or else check the symbol table for the name
		to see if the identifier is declared. Returns the expr_type by calling
		check expression.

	ClassTable::type_check_static_dispatch
		Gets dispatch type and returns error message if NULL given for the type
		lookup on the class table. handle_dispatch is called to get the return
		type. If return type is SELF_TYPE the object type of the expression is
		assigned to it. 

	ClassTable::type_check_dispatch
		Gets the object type by calling type check on expression and assigns
		return_type by calling handle_dispatch. If the return type is SELF_TYPE
		assign the object type to it.

	ClassTable::handle_dispatch
		Handle dispatch is called after type checking the expressions. Here the
		expression, Symbol name and arguments are passed. Iterating throught 
		the arguments checjs are done for the argument expression types. If the
		argument type is read as SELF_TYPE the current class symbol is given to
		it. The argument types are stored in a vector. The dispatch type itself
		is checked for SELF_TYPE if so current class symbol is assigned as the
		dispatch type. 

		The dispatch is searched for in the method table to see if defined or
		not. If so the the declaration is read by method_decls. If this is NULL
		we pass the error as undefined method call. 

		Going through the declarations we check if the arguments stored for the
		current dispatch is descendent of any of them. In other words we check
		for a match. If it matches the found declaration return type is assigned
		to the current dipatch return type. Or else error message passed to show
		that no declarations are found for the specified argument types. 

	ClassTable::type_check_cond
		Type checking for the conditional statements. The 'then' and 'else'
		expressions are checked for type and the final conditional type is
		returned as a union between theses two.
		

	ClassTable::type_union
		Returns the common type of given two symbols. This is done by intially
		creating two stacks for the two given symbols iterate through the
		inheritance trees of each class and add them to the stacks . Then moves
		through the stack popping elements and checking the two top values in each
		iteration for the same type. The last occured common type becomes the
		return of the type_union. 

	ClassTable::type_check_typecase
		Checks the type of case statements. Goes through the cases and get the
		case branch identifiers and their types. Check if the types are defined
		in the class if not error message noifying that undefined type is used
		in the case branch. Checks also done for the multiple branches of the
		same type and logs error if so. Keep the branch types saved in a symbol
		vector. Call the type check ecxpression on the branch expression. If the
		return type is still a null_ptr assign the return if the type check to
		the return. Finally call union on the current return and the branch type
		for the final return.

	ClassTable::type_check_block
		Type checking of a block in COOL. As the block is a collection of
		expressions and the return is its last type value we iterate through
		the expressions and get the last_type. 

	ClassTable::type_check_object
		Checks done on object type checking,
			If the object name is self , then returns SELF_TYPE. Get the type
			from the lookup table and check if the return from the lookup is
			NULL. If so logs error as the identifier is undeclared.

	ClassTable::type_check_let
		Type check for let expressions. Get the type of and identifier for the
		expression along with a pointer to the lookup table entry of the type.
		Checks are done , 
			If the type is not SELF_TYPE and the type ptr is NULL meaning no
			entry in the symbol table error is logged stating the type of let
			binding is undeclared. 'self'identifier is not allowed hence the
			check for self binding and error message. If the checks are passed
			the identifier and type is added to the symbol table and type check
			is done on the initialization of the let expression. The method
			returns the let body type.

	ClassTable::type_check_new_
		if the new_ type is SELF_TYPE returns it. If the lookup table entry is
		not available returns error as it is an undefined new expression.

	ClassTable::type_check_loop
		Type checking for loops in COOL. The predict and the body is type
		checked seperately, however the check for predict type being BOOL return
		error if not satidfied. 

	ClassTable::is_descendant
		Given two symbols check if descendent relationship is satisfied. If the
		already given types are the same we return true. If the descenedent is
		with SELF_TYPE we assign the type of passed current class. A lookup for
		the descenedent is done and iterates through the inheritance to check if
		the type equates to the ancestor at some point. The iteration is
		continued by assigning parent type for to the current type of decendent. 

	ClassTable::install-basic_classes
		Before the declare methods are called through the semantic anlyzer at
		initialization the basic classes are installed. 

Testing
--------------------

Initial tests were done by simply runnning the provided two files of good.cl and
bad.cl

	good.cl
		The COOL program contains a class named C, with attributes of Int a and
		a Bool b. An init method is defined taking to parameters of x (Int) and
		y (Bool). These are assigned to the a,b attributes. In the Main method
		the init method is called.

		Running the file through the lexer gives an output of,
			All the identified identifiers and type identifiers alnog with the
			operators used. The parser output breaks the program into
			identifiable chunks, but lacks certain type information. Finally
			running the sematnic analyzer we can see how the correct types get
			assigned for the expressions.


			LEXER OUTPUT  --> good_lex
			PARSER OUTPTU --> good_parse
			SEMANT OUTPUT --> good_semant


	bad.cl
	 The COOL program contains incorrect method calls. As mentioned before the C
	 class with the init method is used as is here but the calls to the init
	 method happens incorrectly. 

	 (new C).init(1,1)	
		Calls init method but doesnt give the second parameter type of Bool.
		
		bad.cl:16: In call of method init, type Int of parameter y does not conform to declared type Bool.

	(new C).init(1,true,3)
		Passes extra parameter.

		bad.cl:17: Method init called with wrong number of arguments.

	(new C).iinit(1,true)
		calls undefined method

		bad.cl:18: Dispatch to undefined method iinit.



Testing
----------

For testing good and bad test files were used,
	Good

		test1.cl - Illustrates inheritance - Semant gives the correct output 
		test2.cl - Creating a method with name self() is allowed - Semant gives the correct output
		test3.cl - Attributes and initialization - Semant gives the correct output
		test4.cl - Rules for dispatch - Semant gives the correct output
		test5.cl - Test rules of methods - Semant gives the correct output
		test6.cl - Type annotations of constants - Semant gives the correct output
		test7.cl - Rules for identifiers - Semant gives the correct output
		test8.cl - Type annotations for assignments - Semant gives the correct output

	Bad
		test1.cl - Same class defined twice
			test1.cl:15: Class Classx was previously defined.
			Compilation halted due to static semantic errors.
		test2.cl - No Main class
			Class Main is not defined.
			Compilation halted due to static semantic errors.
		test4.cl - Class being inherited from does not exist
			test4.cl:7: Class B inherits from an undefined class C.
			Compilation halted due to static semantic errors.
		test5.cl - Creating object of non-existent class
			test5.cl:4: Class B of attribute a is undefined.
			Compilation halted due to static semantic errors.
		test6.cl - Repeat attribute in inherited class
			test6.cl:8: Attribute a is an attribute of an inherited class.
			test6.cl:16: Attribute c is an attribute of an inherited class.
			Compilation halted due to static semantic errors.
		test7.cl - Function redefinition with different signature or return type
			test7.cl:10: In redefined method f1, return type String is different from original return type Int.
			test7.cl:22: In redefined method f2, parameter type String is different from original type Int
			test7.cl:34: Incompatible number of formal parameters in redefined method f3.
			Compilation halted due to static semantic errors.
		test8.cl - Initialize attribute with non-conforming type
			test8.cl:21: Inferred type A of initialization of attribute a2 does not conform to declared type B.
			test8.cl:23: Inferred type D of initialization of attribute a4 does not conform to declared type B.
			Compilation halted due to static semantic errors.







